 Architecture d'un Générateur de CV Révolutionnaire pour "Immigration97"

​Vision et Contexte :
Tu es l'Architecte en Chef et le Stratège Produit IA pour le projet "Immigration97". Ta mission est de concevoir le plan de développement complet pour le module "CV Generator". Oublie les générateurs de CV traditionnels. Nous ne créons pas un simple outil, mais un "Accélérateur de Carrière Intelligent" pour les nouveaux arrivants. Notre application doit être une arme secrète pour les candidats, en transformant leur expérience brute en un CV percutant, optimisé pour les marchés du travail nord-américains (Canada, USA) et conçu pour déjouer les systèmes de suivi des candidatures (ATS). La valeur ajoutée fondamentale et non négociable de notre produit réside dans son intégration profonde et intelligente avec des modèles de langage avancés via l'API d'OpenAI (GPT-4).
​Analyse Concurrentielle (Base de Référence : moncvparfait.fr)
Le concurrent propose des modèles et des suggestions basiques. C'est notre point de départ, pas notre destination. Nous allons le surpasser en offrant non pas des suggestions, mais un coaching de carrière personnalisé et automatisé à chaque étape. Notre avantage concurrentiel sera une expérience utilisateur (UX) qui semble magique, simple en surface mais incroyablement puissante en coulisses.
​I. L'Expérience Utilisateur Intelligente (IX) : Le Parcours Guidé
​Conçois une interface épurée, minimaliste et ultra-rapide (type Single Page Application) qui guide l'utilisateur à travers les étapes suivantes, chacune enrichie par l'IA :
​Étape 1 : Le Point de Départ Stratégique
L'utilisateur ne choisit pas un modèle au hasard. Il renseigne deux choses :

​Son domaine d'activité (ex: "Ingénierie logicielle", "Soins de santé", "Logistique").

​Son pays cible (ex: "Canada").

​Action de l'IA : Basé sur ces informations, l'IA recommande les 3 modèles de CV les plus performants pour ce secteur et ce pays, en expliquant pourquoi (ex: "Ce modèle chronologique est préféré par 80% des recruteurs tech au Canada").
​Étape 2 : Le Résumé de Carrière "Impact"
Au lieu d'un champ de texte vide, l'IA pose des questions : "Quel est le titre de poste le plus récent que vous avez occupé ?" et "Combien d'années d'expérience avez-vous dans ce domaine ?".
​Action de l'IA (Appel API OpenAI) : L'IA génère 3 propositions de résumés de carrière percutants. Ces résumés sont rédigés dans un style nord-américain, intègrent des mots-clés pertinents pour le secteur et utilisent des verbes d'action puissants.
​Étape 3 : La Transformation des Expériences
L'utilisateur ajoute une expérience professionnelle (titre, entreprise, dates). Pour la description, il écrit des phrases simples.

​Exemple utilisateur : "J'ai géré les projets de l'équipe."

​Action de l'IA (Appel API OpenAI) : L'IA analyse la phrase et engage un dialogue pour la transformer en une réalisation quantifiable.

​IA : "Intéressant. Pouvez-vous quantifier cela ? Combien de projets ? Quelle était la taille de l'équipe ? Avez-vous terminé dans les délais ou le budget ?"

​Utilisateur : "Environ 5 projets, équipe de 10 personnes, j'ai respecté le budget."

​L'IA reformule en : "✓ Pilotage réussi de 5 projets stratégiques de la conception à la livraison, en coordonnant une équipe de 10 personnes et en garantissant le respect strict des contraintes budgétaires."

​Étape 4 : L'Optimiseur de Compétences pour ATS
L'utilisateur liste ses compétences en vrac (ex: "Python, gestion de projet, anglais, service client").
​Action de l'IA (Appel API OpenAI) :

​Catégorisation Automatique : L'IA trie et regroupe les compétences (Langues, Compétences Techniques, Compétences Interpersonnelles).

​Suggestion de Mots-clés : En se basant sur le poste visé, l'IA analyse des offres d'emploi réelles et suggère des compétences et des mots-clés manquants, essentiels pour passer les filtres ATS. (ex: "Pour un poste de développeur au Canada, envisagez d'ajouter 'Git', 'CI/CD' et 'Agile/Scrum'").

​Étape 5 : Le Contrôle Qualité Final par l'IA
Avant le téléchargement, l'utilisateur soumet son CV à une "Revue IA".
​Action de l'IA (Appel API OpenAI) : L'IA attribue un "Score d'Impact" au CV basé sur plusieurs critères :

​Compatibilité ATS (%).

​Utilisation de verbes d'action.

​Quantification des résultats.

​Absence de fautes de frappe et de grammaire.

​Adéquation avec les standards du pays cible.

​L'IA fournit une liste de recommandations finales et exploitables pour atteindre un score supérieur à 95%.
​II. Architecture Technique Robuste et Évolutive
​Propose une architecture complète pour ce produit.

​Framework Backend : Python avec Django. L'architecture doit être basée sur des services, avec une API RESTful claire (utilisant Django REST Framework).

​Framework Frontend : React.js ou Vue.js. L'expérience doit être fluide, sans rechargement de page.

​Base de Données : PostgreSQL. Conçois un schéma de base de données flexible qui stocke les informations du CV sous forme de JSON pour une manipulation facile.

​Intégration IA : Tous les appels aux modèles de langage doivent passer par le backend. Crée un module de service dédié (ex: openai_service.py) qui gère les appels à l'API d'OpenAI, le formatage des prompts et le traitement des réponses.

​Génération PDF : Utilise WeasyPrint pour une conversion parfaite du HTML en PDF de haute qualité, garantissant que le design du modèle est respecté à la lettre.

​III. Livrables Attendus
​Fournis un plan de développement complet et détaillé :

​Le Schéma de l'API RESTful : Liste tous les endpoints nécessaires (/cv, /cv/experience, /cv/analyze), avec les méthodes HTTP, les requêtes et les réponses attendues. Inclure les endpoints qui interagiront avec le service OpenAI.

​L'Architecture des Prompts IA : Pour chaque fonctionnalité IA, fournis le "mega-prompt" système qui sera envoyé à l'API d'OpenAI pour garantir des réponses de haute qualité et cohérentes.

​La Structure des Composants Frontend : Décompose l'interface en composants logiques (ex: <TemplateRecommender>, <ExperienceEnhancer>, <AIReviewModal>).

​La Feuille de Route de Développement : Séquence le développement en sprints logiques, en commençant par le squelette de l'application, puis en intégrant une fonctionnalité IA après l'autre, pour une montée en puissance progressive.

​Notre objectif est de livrer un produit qui ne se contente pas de mettre en forme des informations, mais qui transforme des carrières. Faisons de "Immigration97 CV Generator" la référence absolue. 
donc on peut deja commencer les differentes pages pour mon application cv generator tu me guide pas a pas avec les codes python et django merci c'est toi l'expert j'attent


voila les fichiers et les codes que j'ai presentement
nous allons continuer avec ce que j'ai tu as compris le concept je suis nouveau en programmation avec python et django donc tu dois me donner les code à coller et les chemins a suivre
l'application cv_generator est deja connecté a ma page d'accueil donc j'accede à l'application a partir de ma page d'accueil donc j'ai la page de bienvenue dans le createur de cv et le lien pour voir les cv creer donc tu connais ce que tu dois me donner comme suite j'ai installer docker desktop et quelques truc aussi que l'ia m'a demandé d'installer 


# cv_generator/services/openai_service.py
import openai
from django.conf import settings
import json
import os

class OpenAIService:
    """
    Service centralisé pour toutes les interactions avec l'API OpenAI
    """
    
    def __init__(self):
        # Récupérer la clé API depuis les settings ou les variables d'environnement
        self.api_key = getattr(settings, 'OPENAI_API_KEY', os.getenv('OPENAI_API_KEY'))
        if self.api_key:
            openai.api_key = self.api_key
        self.model = "gpt-4"  # ou "gpt-3.5-turbo" pour réduire les coûts
    
    def _call_openai(self, system_prompt, user_prompt, temperature=0.7):
        """
        Méthode privée pour appeler l'API OpenAI
        """
        if not self.api_key:
            # Mode démo sans API key
            return self._get_demo_response(system_prompt, user_prompt)
        
        try:
            response = openai.ChatCompletion.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                temperature=temperature,
                max_tokens=1000
            )
            return response.choices[0].message.content.strip()
        except Exception as e:
            print(f"OpenAI API Error: {str(e)}")
            # Retourner une réponse de démo en cas d'erreur
            return self._get_demo_response(system_prompt, user_prompt)
    
    def _get_demo_response(self, system_prompt, user_prompt):
        """
        Réponses de démonstration quand l'API n'est pas disponible
        """
        if "template" in system_prompt.lower():
            return "Ce template est recommandé car il est privilégié par 80% des recruteurs dans votre secteur."
        elif "summary" in system_prompt.lower() or "résumé" in system_prompt.lower():
            return "1. Professionnel expérimenté avec une expertise démontrée dans le domaine.\n2. Expert dynamique avec plusieurs années d'expérience réussie.\n3. Spécialiste compétent reconnu pour ses réalisations."
        elif "question" in system_prompt.lower():
            return "- Combien de projets avez-vous gérés?\n- Quelle était la taille de votre équipe?\n- Quels résultats mesurables avez-vous obtenus?"
        elif "enhance" in system_prompt.lower():
            return "✓ Gestion stratégique de projets avec des résultats mesurables et dépassement des objectifs fixés."
        elif "skill" in system_prompt.lower():
            return json.dumps({
                "categorized": {
                    "technical": ["Python", "Django"],
                    "languages": ["Français", "Anglais"],
                    "soft": ["Leadership", "Communication"]
                },
                "suggestions": ["Git", "Docker", "CI/CD"],
                "ats_keywords": ["Agile", "Scrum", "Project Management"]
            })
        elif "analyze" in system_prompt.lower():
            return json.dumps({
                "ats_score": 75,
                "breakdown": {
                    "ats_compatibility": 22,
                    "action_verbs": 16,
                    "quantification": 18,
                    "grammar": 12,
                    "local_standards": 7
                },
                "recommendations": [
                    "Ajoutez plus de métriques quantifiables dans vos expériences",
                    "Utilisez des verbes d'action plus percutants",
                    "Optimisez vos mots-clés pour l'ATS"
                ]
            })
        return "Réponse de démonstration - Configurez votre clé API OpenAI pour des résultats optimaux."
    
    def explain_template_recommendation(self, template_name, industry, country):
        """
        Génère une explication personnalisée pour une recommandation de template
        """
        system_prompt = """Tu es un expert en recrutement et en CV pour le marché nord-américain.
        Explique de manière concise (max 50 mots) pourquoi un template de CV est recommandé pour 
        un secteur et un pays donnés."""
        
        user_prompt = f"""Template: {template_name}
Secteur: {industry}
Pays: {country}

Explique en 1-2 phrases pourquoi ce template est recommandé."""
        
        return self._call_openai(system_prompt, user_prompt, temperature=0.7)
    
    def generate_career_summaries(self, job_title, years_experience, industry, country):
        """
        Génère 3 résumés de carrière percutants
        """
        system_prompt = f"""Tu es un expert en rédaction de CV pour le marché {country}.
        Tu dois créer des résumés de carrière percutants qui:
        - Utilisent des verbes d'action puissants
        - Intègrent des mots-clés du secteur {industry}
        - Sont optimisés pour les ATS
        - Sont rédigés dans un style {country}
        - Font 3-4 lignes maximum
        
        Génère EXACTEMENT 3 propositions différentes, numérotées 1, 2, 3."""
        
        user_prompt = f"""Poste: {job_title}
Expérience: {years_experience} ans
Secteur: {industry}

Génère 3 résumés de carrière distincts."""
        
        response = self._call_openai(system_prompt, user_prompt, temperature=0.8)
        
        # Parser la réponse pour extraire les 3 résumés
        summaries = []
        if response:
            lines = response.split('\n')
            current_summary = ""
            for line in lines:
                line = line.strip()
                if line.startswith(('1.', '2.', '3.')):
                    if current_summary:
                        summaries.append(current_summary.strip())
                    current_summary = line[2:].strip()
                elif current_summary:
                    current_summary += " " + line
            if current_summary:
                summaries.append(current_summary.strip())
        
        # S'assurer qu'on a au moins 3 résumés
        while len(summaries) < 3:
            summaries.append(f"Professionnel expérimenté en {industry} avec {years_experience} ans d'expertise.")
        
        return summaries[:3]
    
    def generate_clarifying_questions(self, raw_description, job_title, industry):
        """
        Génère des questions pour clarifier une description d'expérience
        """
        system_prompt = f"""Tu es un coach de carrière expert pour le secteur {industry}.
        Analyse la description d'une tâche professionnelle et pose 3-4 questions précises pour:
        - Quantifier les résultats
        - Identifier l'impact
        - Clarifier le contexte
        
        Pose des questions courtes et directes."""
        
        user_prompt = f"""Poste: {job_title}
Description: {raw_description}

Quelles questions poser pour améliorer cette description?"""
        
        response = self._call_openai(system_prompt, user_prompt, temperature=0.7)
        
        # Parser les questions
        questions = []
        if response:
            lines = response.split('\n')
            for line in lines:
                line = line.strip()
                if line and ('?' in line or line.startswith(('-', '•', '*'))):
                    question = line.lstrip('-•*').strip()
                    if question:
                        questions.append(question)
        
        # S'assurer qu'on a au moins 3 questions
        if len(questions) < 3:
            questions.extend([
                "Pouvez-vous quantifier vos résultats?",
                "Quelle était la taille de votre équipe?",
                "Quel impact avez-vous eu sur l'organisation?"
            ])
        
        return questions[:4]
    
    def enhance_experience_description(self, raw_description, job_title, industry, clarifications):
        """
        Améliore une description d'expérience avec les clarifications fournies
        """
        system_prompt = f"""Tu es un expert en rédaction de CV pour le secteur {industry}.
        Transforme une description basique en une réalisation quantifiable et percutante qui:
        - Commence par un verbe d'action fort
        - Inclut des chiffres et des métriques
        - Montre l'impact et les résultats
        - Est optimisée pour les ATS
        - Fait 2-3 lignes maximum
        
        Utilise le symbole ✓ au début."""
        
        clarifications_text = "\n".join([f"- {k}: {v}" for k, v in clarifications.items()])
        
        user_prompt = f"""Poste: {job_title}
Description originale: {raw_description}

Clarifications:
{clarifications_text}

Reformule en une réalisation professionnelle percutante."""
        
        return self._call_openai(system_prompt, user_prompt, temperature=0.7)
    
    def optimize_skills(self, skills, job_title, industry, country):
        """
        Catégorise les compétences et suggère des mots-clés ATS
        """
        system_prompt = f"""Tu es un expert ATS et recruteur pour {country} dans le secteur {industry}.
        
        Tâche 1: Catégorise les compétences en:
        - Compétences Techniques
        - Langues
        - Compétences Interpersonnelles
        
        Tâche 2: Suggère 5-8 compétences/mots-clés manquants essentiels pour ce poste.
        
        Tâche 3: Liste les mots-clés ATS critiques pour le secteur.
        
        Retourne un JSON avec cette structure:
        {{
            "categorized": {{
                "technical": [...],
                "languages": [...],
                "soft": [...]
            }},
            "suggestions": [...],
            "ats_keywords": [...]
        }}"""
        
        skills_text = ", ".join(skills) if isinstance(skills, list) else skills
        user_prompt = f"""Poste: {job_title}
Compétences actuelles: {skills_text}

Analyse et optimise ces compétences."""
        
        response = self._call_openai(system_prompt, user_prompt, temperature=0.5)
        
        try:
            # Essayer de parser le JSON
            result = json.loads(response)
            return result
        except:
            # Fallback si le JSON n'est pas valide
            return {
                "categorized": {
                    "technical": skills if isinstance(skills, list) else [skills],
                    "languages": [],
                    "soft": []
                },
                "suggestions": ["Git", "Docker", "Agile", "Leadership"],
                "ats_keywords": ["Project Management", "Team Collaboration"]
            }
    
    def analyze_cv_quality(self, cv_data, industry, country):
        """
        Analyse la qualité globale du CV et génère un score ATS
        """
        system_prompt = f"""Tu es un système ATS (Applicant Tracking System) expert pour {country}.
        Analyse un CV et attribue un score sur 100 basé sur:
        - Compatibilité ATS (30 points)
        - Utilisation de verbes d'action (20 points)
        - Quantification des résultats (25 points)
        - Qualité de la grammaire (15 points)
        - Adéquation avec les standards {country} (10 points)
        
        Retourne un JSON avec:
        {{
            "ats_score": <score total>,
            "breakdown": {{
                "ats_compatibility": <score>,
                "action_verbs": <score>,
                "quantification": <score>,
                "grammar": <score>,
                "local_standards": <score>
            }},
            "recommendations": [
                "Recommandation 1",
                "Recommandation 2",
                ...
            ]
        }}"""
        
        experiences_count = len(cv_data.get('experiences', [])) if cv_data else 0
        skills_list = cv_data.get('skills', {}).get('technical', []) if cv_data else []
        skills_text = ', '.join(skills_list) if skills_list else 'Aucune'
        
        cv_summary = f"""Secteur: {industry}
Résumé de carrière: {cv_data.get('career_summary', 'Aucun') if cv_data else 'Aucun'}
Nombre d'expériences: {experiences_count}
Compétences: {skills_text}"""
        
        user_prompt = f"Analyse ce CV:\n\n{cv_summary}"
        
        response = self._call_openai(system_prompt, user_prompt, temperature=0.3)
        
        try:
            result = json.loads(response)
            return result
        except:
            # Fallback
            return {
                "ats_score": 70,
                "breakdown": {
                    "ats_compatibility": 20,
                    "action_verbs": 15,
                    "quantification": 15,
                    "grammar": 12,
                    "local_standards": 8
                },
                "recommendations": [
                    "Ajoutez plus de métriques quantifiables dans vos expériences",
                    "Utilisez des verbes d'action plus forts",
                    "Optimisez vos mots-clés pour passer les filtres ATS"
                ]
            }


cv list.html
{% extends "base.html" %}

{% block content %}
<h1>Mes CV</h1>
<p>Ici seront listés vos CV créés.</p>
{% endblock %}



cv index.html
{% extends "base.html" %}

{% block content %}
<h1>Bienvenue dans le générateur de CV</h1>
<p>Cliquez sur "Créer un CV" pour commencer.</p>
<a href="{% url 'cv_list' %}">Voir mes CV</a>
{% endblock %}


# cv_generator/models.py
from django.db import models
from django.contrib.auth.models import User
import json

class CVTemplate(models.Model):
    """Modèles de CV disponibles"""
    name = models.CharField(max_length=100)
    description = models.TextField()
    industry = models.CharField(max_length=100)  # Secteur d'activité
    country = models.CharField(max_length=50)  # Pays cible
    popularity_score = models.IntegerField(default=0)  # Score de popularité
    html_template = models.TextField()  # Template HTML
    thumbnail = models.ImageField(upload_to='cv_templates/', null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        ordering = ['-popularity_score']
    
    def __str__(self):
        return f"{self.name} - {self.industry} ({self.country})"


class CV(models.Model):
    """CV de l'utilisateur"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='cvs')
    template = models.ForeignKey(CVTemplate, on_delete=models.SET_NULL, null=True)
    
    # Informations de base
    industry = models.CharField(max_length=100)
    target_country = models.CharField(max_length=50)
    
    # Données du CV stockées en JSON
    data = models.JSONField(default=dict)
    # Structure de data:
    # {
    #     "personal_info": {...},
    #     "career_summary": "...",
    #     "experiences": [...],
    #     "education": [...],
    #     "skills": {...},
    #     "languages": [...]
    # }
    
    # Score et analyse
    ats_score = models.IntegerField(default=0)
    ai_recommendations = models.JSONField(default=list)
    
    # Métadonnées
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    is_completed = models.BooleanField(default=False)
    
    class Meta:
        ordering = ['-updated_at']
    
    def __str__(self):
        return f"CV de {self.user.username} - {self.industry}"
    
    def get_data(self, key, default=None):
        """Récupère une valeur du JSON data"""
        return self.data.get(key, default)
    
    def set_data(self, key, value):
        """Définit une valeur dans le JSON data"""
        self.data[key] = value
        self.save()


class Experience(models.Model):
    """Expériences professionnelles"""
    cv = models.ForeignKey(CV, on_delete=models.CASCADE, related_name='experiences')
    job_title = models.CharField(max_length=200)
    company = models.CharField(max_length=200)
    location = models.CharField(max_length=200, blank=True)
    start_date = models.DateField()
    end_date = models.DateField(null=True, blank=True)
    is_current = models.BooleanField(default=False)
    
    # Description originale et améliorée
    original_description = models.TextField()
    enhanced_description = models.TextField(blank=True)
    
    order = models.IntegerField(default=0)
    
    class Meta:
        ordering = ['order', '-start_date']
    
    def __str__(self):
        return f"{self.job_title} chez {self.company}"


class AIInteraction(models.Model):
    """Historique des interactions avec l'IA"""
    cv = models.ForeignKey(CV, on_delete=models.CASCADE, related_name='ai_interactions')
    interaction_type = models.CharField(max_length=50)  # 'summary', 'experience', 'skills', 'analysis'
    user_input = models.TextField()
    ai_response = models.TextField()
    prompt_used = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        ordering = ['-created_at']
    
    def __str__(self):
        return f"{self.interaction_type} - {self.created_at.strftime('%Y-%m-%d %H:%M')}"


# cv_generator/services/openai_service.py
import openai
from django.conf import settings
import json

class OpenAIService:
    """
    Service centralisé pour toutes les interactions avec l'API OpenAI
    """
    
    def __init__(self):
        openai.api_key = settings.OPENAI_API_KEY
        self.model = "gpt-4"  # ou "gpt-3.5-turbo" pour réduire les coûts
    
    def _call_openai(self, system_prompt, user_prompt, temperature=0.7):
        """
        Méthode privée pour appeler l'API OpenAI
        """
        try:
            response = openai.ChatCompletion.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                temperature=temperature,
                max_tokens=1000
            )
            return response.choices[0].message.content.strip()
        except Exception as e:
            print(f"OpenAI API Error: {str(e)}")
            return None
    
    def explain_template_recommendation(self, template_name, industry, country):
        """
        Génère une explication personnalisée pour une recommandation de template
        """
        system_prompt = """Tu es un expert en recrutement et en CV pour le marché nord-américain.
        Explique de manière concise (max 50 mots) pourquoi un template de CV est recommandé pour 
        un secteur et un pays donnés."""
        
        user_prompt = f"""Template: {template_name}
Secteur: {industry}
Pays: {country}

Explique en 1-2 phrases pourquoi ce template est recommandé."""
        
        return self._call_openai(system_prompt, user_prompt, temperature=0.7)
    
    def generate_career_summaries(self, job_title, years_experience, industry, country):
        """
        Génère 3 résumés de carrière percutants
        """
        system_prompt = f"""Tu es un expert en rédaction de CV pour le marché {country}.
        Tu dois créer des résumés de carrière percutants qui:
        - Utilisent des verbes d'action puissants
        - Intègrent des mots-clés du secteur {industry}
        - Sont optimisés pour les ATS
        - Sont rédigés dans un style {country}
        - Font 3-4 lignes maximum
        
        Génère EXACTEMENT 3 propositions différentes, numérotées 1, 2, 3."""
        
        user_prompt = f"""Poste: {job_title}
Expérience: {years_experience} ans
Secteur: {industry}

Génère 3 résumés de carrière distincts."""
        
        response = self._call_openai(system_prompt, user_prompt, temperature=0.8)
        
        # Parser la réponse pour extraire les 3 résumés
        summaries = []
        if response:
            lines = response.split('\n')
            current_summary = ""
            for line in lines:
                line = line.strip()
                if line.startswith(('1.', '2.', '3.')):
                    if current_summary:
                        summaries.append(current_summary.strip())
                    current_summary = line[2:].strip()
                elif current_summary:
                    current_summary += " " + line
            if current_summary:
                summaries.append(current_summary.strip())
        
        return summaries[:3]
    
    def generate_clarifying_questions(self, raw_description, job_title, industry):
        """
        Génère des questions pour clarifier une description d'expérience
        """
        system_prompt = f"""Tu es un coach de carrière expert pour le secteur {industry}.
        Analyse la description d'une tâche professionnelle et pose 3-4 questions précises pour:
        - Quantifier les résultats
        - Identifier l'impact
        - Clarifier le contexte
        
        Pose des questions courtes et directes."""
        
        user_prompt = f"""Poste: {job_title}
Description: {raw_description}

Quelles questions poser pour améliorer cette description?"""
        
        response = self._call_openai(system_prompt, user_prompt, temperature=0.7)
        
        # Parser les questions
        questions = []
        if response:
            lines = response.split('\n')
            for line in lines:
                line = line.strip()
                if line and ('?' in line or line.startswith(('-', '•', '*'))):
                    question = line.lstrip('-•*').strip()
                    if question:
                        questions.append(question)
        
        return questions[:4]
    
    def enhance_experience_description(self, raw_description, job_title, industry, clarifications):
        """
        Améliore une description d'expérience avec les clarifications fournies
        """
        system_prompt = f"""Tu es un expert en rédaction de CV pour le secteur {industry}.
        Transforme une description basique en une réalisation quantifiable et percutante qui:
        - Commence par un verbe d'action fort
        - Inclut des chiffres et des métriques
        - Montre l'impact et les résultats
        - Est optimisée pour les ATS
        - Fait 2-3 lignes maximum
        
        Utilise le symbole ✓ au début."""
        
        clarifications_text = "\n".join([f"- {k}: {v}" for k, v in clarifications.items()])
        
        user_prompt = f"""Poste: {job_title}
Description originale: {raw_description}

Clarifications:
{clarifications_text}

Reformule en une réalisation professionnelle percutante."""
        
        return self._call_openai(system_prompt, user_prompt, temperature=0.7)
    
    def optimize_skills(self, skills, job_title, industry, country):
        """
        Catégorise les compétences et suggère des mots-clés ATS
        """
        system_prompt = f"""Tu es un expert ATS et recruteur pour {country} dans le secteur {industry}.
        
        Tâche 1: Catégorise les compétences en:
        - Compétences Techniques
        - Langues
        - Compétences Interpersonnelles
        
        Tâche 2: Suggère 5-8 compétences/mots-clés manquants essentiels pour ce poste.
        
        Tâche 3: Liste les mots-clés ATS critiques pour le secteur.
        
        Retourne un JSON avec cette structure:
        {{
            "categorized": {{
                "technical": [...],
                "languages": [...],
                "soft": [...]
            }},
            "suggestions": [...],
            "ats_keywords": [...]
        }}"""
        
        skills_text = ", ".join(skills)
        user_prompt = f"""Poste: {job_title}
Compétences actuelles: {skills_text}

Analyse et optimise ces compétences."""
        
        response = self._call_openai(system_prompt, user_prompt, temperature=0.5)
        
        try:
            # Essayer de parser le JSON
            result = json.loads(response)
            return result
        except:
            # Fallback si le JSON n'est pas valide
            return {
                "categorized": {
                    "technical": skills,
                    "languages": [],
                    "soft": []
                },
                "suggestions": [],
                "ats_keywords": []
            }
    
    def analyze_cv_quality(self, cv_data, industry, country):
        """
        Analyse la qualité globale du CV et génère un score ATS
        """
        system_prompt = f"""Tu es un système ATS (Applicant Tracking System) expert pour {country}.
        Analyse un CV et attribue un score sur 100 basé sur:
        - Compatibilité ATS (30 points)
        - Utilisation de verbes d'action (20 points)
        - Quantification des résultats (25 points)
        - Qualité de la grammaire (15 points)
        - Adéquation avec les standards {country} (10 points)
        
        Retourne un JSON avec:
        {{
            "ats_score": <score total>,
            "breakdown": {{
                "ats_compatibility": <score>,
                "action_verbs": <score>,
                "quantification": <score>,
                "grammar": <score>,
                "local_standards": <score>
            }},
            "recommendations": [
                "Recommandation 1",
                "Recommandation 2",
                ...
            ]
        }}"""
        
        cv_summary = f"""Secteur: {industry}
Résumé de carrière: {cv_data.get('career_summary', 'Aucun')}
Nombre d'expériences: {len(cv_data.get('experiences', []))}
Compétences: {', '.join(cv_data.get('skills', {}).get('technical', []))}"""
        
        user_prompt = f"Analyse ce CV:\n\n{cv_summary}"
        
        response = self._call_openai(system_prompt, user_prompt, temperature=0.3)
        
        try:
            result = json.loads(response)
            return result
        except:
            # Fallback
            return {
                "ats_score": 70,
                "breakdown": {
                    "ats_compatibility": 20,
                    "action_verbs": 15,
                    "quantification": 15,
                    "grammar": 12,
                    "local_standards": 8
                },
                "recommendations": [
                    "Ajoutez plus de métriques quantifiables",
                    "Utilisez des verbes d'action plus forts"
                ]
            }


cv_generato/serializers
from rest_framework import serializers
from .models import CV

class CVSerializer(serializers.ModelSerializer):
    class Meta:
        model = CV
        fields = '__all__'

cv_generator/urls.py
from django.urls import path
from . import views

urlpatterns = [
    path('cv/', views.cv_list_view, name='cv_list'),  # Nom exact ici
    path('', views.index, name='index'),
]


cv_generator/views.py
# cv_generator/views.py
from django.shortcuts import render, get_object_or_404
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
from django.contrib.auth.decorators import login_required
from django.views.decorators.http import require_http_methods
import json
from .models import CV, CVTemplate, Experience, AIInteraction
from .services.openai_service import OpenAIService

# Initialiser le service OpenAI
ai_service = OpenAIService()


# ============================================
# PAGES HTML (Vues Template)
# ============================================

def index(request):
    """Page d'accueil du générateur de CV"""
    return render(request, 'cv_generator/index.html')


@login_required
def create_cv(request):
    """Page de création de CV"""
    # Récupérer ou créer un CV en cours pour l'utilisateur
    cv, created = CV.objects.get_or_create(
        user=request.user,
        is_completed=False,
        defaults={
            'industry': '',
            'target_country': '',
            'data': {}
        }
    )
    
    context = {
        'cv': cv,
        'templates': CVTemplate.objects.all()
    }
    return render(request, 'cv_generator/create_cv.html', context)


# ============================================
# API ENDPOINTS
# ============================================

@csrf_exempt
@require_http_methods(["POST"])
def recommend_templates(request):
    """
    Recommande les 3 meilleurs templates basés sur l'industrie et le pays cible
    """
    try:
        data = json.loads(request.body)
        industry = data.get('industry', '')
        country = data.get('country', '')
        
        if not industry or not country:
            return JsonResponse({
                'error': 'Industry and country are required'
            }, status=400)
        
        # Récupérer les templates correspondants
        templates = CVTemplate.objects.filter(
            industry__icontains=industry,
            country=country
        )[:3]
        
        # Si moins de 3 templates trouvés, compléter avec les plus populaires
        if templates.count() < 3:
            additional = CVTemplate.objects.exclude(
                id__in=[t.id for t in templates]
            ).order_by('-popularity_score')[:3 - templates.count()]
            templates = list(templates) + list(additional)
        
        # Utiliser l'IA pour générer des explications
        template_data = []
        for template in templates:
            # Générer une explication personnalisée avec l'IA
            explanation = ai_service.explain_template_recommendation(
                template.name,
                industry,
                country
            )
            
            template_data.append({
                'id': template.id,
                'name': template.name,
                'description': template.description,
                'explanation': explanation,
                'thumbnail': template.thumbnail.url if template.thumbnail else None
            })
        
        return JsonResponse({
            'success': True,
            'templates': template_data
        })
        
    except Exception as e:
        return JsonResponse({
            'error': str(e)
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def generate_summary(request):
    """
    Génère 3 propositions de résumé de carrière basées sur le titre et l'expérience
    """
    try:
        data = json.loads(request.body)
        job_title = data.get('job_title', '')
        years_experience = data.get('years_experience', 0)
        industry = data.get('industry', '')
        country = data.get('country', '')
        
        if not job_title:
            return JsonResponse({
                'error': 'Job title is required'
            }, status=400)
        
        # Générer 3 résumés avec l'IA
        summaries = ai_service.generate_career_summaries(
            job_title=job_title,
            years_experience=years_experience,
            industry=industry,
            country=country
        )
        
        return JsonResponse({
            'success': True,
            'summaries': summaries
        })
        
    except Exception as e:
        return JsonResponse({
            'error': str(e)
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def enhance_experience(request):
    """
    Améliore la description d'une expérience professionnelle
    """
    try:
        data = json.loads(request.body)
        raw_description = data.get('description', '')
        job_title = data.get('job_title', '')
        industry = data.get('industry', '')
        
        if not raw_description:
            return JsonResponse({
                'error': 'Description is required'
            }, status=400)
        
        # Première étape: L'IA pose des questions pour clarifier
        questions = ai_service.generate_clarifying_questions(
            raw_description,
            job_title,
            industry
        )
        
        # Si l'utilisateur a fourni des réponses aux questions
        if 'answers' in data:
            enhanced_description = ai_service.enhance_experience_description(
                raw_description=raw_description,
                job_title=job_title,
                industry=industry,
                clarifications=data['answers']
            )
            
            return JsonResponse({
                'success': True,
                'enhanced_description': enhanced_description,
                'needs_clarification': False
            })
        
        return JsonResponse({
            'success': True,
            'questions': questions,
            'needs_clarification': True
        })
        
    except Exception as e:
        return JsonResponse({
            'error': str(e)
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def optimize_skills(request):
    """
    Optimise et catégorise les compétences pour ATS
    """
    try:
        data = json.loads(request.body)
        raw_skills = data.get('skills', [])
        job_title = data.get('job_title', '')
        industry = data.get('industry', '')
        country = data.get('country', '')
        
        if not raw_skills:
            return JsonResponse({
                'error': 'Skills are required'
            }, status=400)
        
        # Utiliser l'IA pour catégoriser et suggérer des compétences
        optimization = ai_service.optimize_skills(
            skills=raw_skills,
            job_title=job_title,
            industry=industry,
            country=country
        )
        
        return JsonResponse({
            'success': True,
            'categorized_skills': optimization['categorized'],
            'suggested_skills': optimization['suggestions'],
            'ats_keywords': optimization['ats_keywords']
        })
        
    except Exception as e:
        return JsonResponse({
            'error': str(e)
        }, status=500)


@csrf_exempt
@require_http_methods(["POST"])
def analyze_cv(request):
    """
    Analyse complète du CV avec score ATS et recommandations
    """
    try:
        data = json.loads(request.body)
        cv_id = data.get('cv_id')
        
        if not cv_id:
            return JsonResponse({
                'error': 'CV ID is required'
            }, status=400)
        
        cv = get_object_or_404(CV, id=cv_id)
        
        # Analyser le CV avec l'IA
        analysis = ai_service.analyze_cv_quality(
            cv_data=cv.data,
            industry=cv.industry,
            country=cv.target_country
        )
        
        # Sauvegarder le score et les recommandations
        cv.ats_score = analysis['ats_score']
        cv.ai_recommendations = analysis['recommendations']
        cv.save()
        
        return JsonResponse({
            'success': True,
            'ats_score': analysis['ats_score'],
            'breakdown': analysis['breakdown'],
            'recommendations': analysis['recommendations']
        })
        
    except Exception as e:
        return JsonResponse({
            'error': str(e)
        }, status=500)


@csrf_exempt
@login_required
@require_http_methods(["POST"])
def save_cv(request):
    """
    Sauvegarde les données du CV
    """
    try:
        data = json.loads(request.body)
        cv_id = data.get('cv_id')
        
        if cv_id:
            cv = get_object_or_404(CV, id=cv_id, user=request.user)
        else:
            cv = CV.objects.create(user=request.user)
        
        # Mettre à jour les champs
        if 'industry' in data:
            cv.industry = data['industry']
        if 'target_country' in data:
            cv.target_country = data['target_country']
        if 'template_id' in data:
            cv.template_id = data['template_id']
        if 'data' in data:
            cv.data = data['data']
        
        cv.save()
        
        return JsonResponse({
            'success': True,
            'cv_id': cv.id
        })
        
    except Exception as e:
        return JsonResponse({
            'error': str(e)
        }, status=500)


@login_required
@require_http_methods(["GET"])
def generate_pdf(request):
    """
    Génère un PDF du CV
    """
    try:
        cv_id = request.GET.get('cv_id')
        cv = get_object_or_404(CV, id=cv_id, user=request.user)
        
        # TODO: Implémenter la génération PDF avec WeasyPrint
        # Pour l'instant, retourner un message
        
        return JsonResponse({
            'success': True,
            'message': 'PDF generation will be implemented'
        })
        
    except Exception as e:
        return JsonResponse({
            'error': str(e)
        }, status=500)

def index(request):
    return render(request, 'cv_generator/index.html')


def cv_list_view(request):
    # Ici tu peux récupérer les CV depuis la base de données si besoin
    return render(request, 'cv_generator/cv_list.html')

